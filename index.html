<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Hexanoid ‚Äî Infinite Mode</title>
<style>
  :root{--bg:#0b0b0b;--frame:#141414;--accent:#3ee}
  html,body{height:100%;margin:0;background:var(--bg);color:#ddd;font-family:system-ui,Arial,sans-serif}
  #app{height:100%;display:flex;flex-direction:column;padding:12px;box-sizing:border-box}
  #title{height:44px;display:flex;align-items:center;justify-content:center;font-weight:600;background:var(--frame);border-radius:8px;padding:6px 12px}
  .frame{flex:1;margin-top:12px;border:4px solid var(--accent);border-radius:12px;box-shadow:0 12px 30px rgba(0,0,0,0.6);background:#070707;display:flex;align-items:center;justify-content:center;position:relative;overflow:hidden}
  canvas{display:block;touch-action:none;max-width:100%;height:auto}
  #status{margin-top:10px;text-align:center;color:#aab}
  .controls{margin-top:8px;display:flex;gap:8px;justify-content:center;flex-wrap:wrap}
  button{background:#1f1f1f;border:1px solid #2b2b2b;color:#ddd;padding:8px 12px;border-radius:8px;cursor:pointer}
  .mode-select{display:flex;gap:8px;align-items:center;margin-bottom:8px;flex-wrap:wrap}
  .speed-control{display:flex;gap:8px;align-items:center;margin-bottom:8px}
  .completion{color:#4cc98a;font-weight:bold}
  .active-powerup{margin:5px 0;padding:3px 8px;border-radius:4px;font-size:12px;display:inline-block;margin-right:5px;}
  .powerup-multiball{background:linear-gradient(45deg, #ff6b6b, #c44569);}
  .powerup-freeze{background:linear-gradient(45deg, #4d96ff, #6bc5ff);}
  .powerup-pierce{background:linear-gradient(45deg, #9b59b6, #8e44ad);}
  .powerup-triple{background:linear-gradient(45deg, #f39c12, #e67e22);}
  @media (max-width:520px){ #title{font-size:14px} button{padding:8px 10px} .mode-select,.speed-control{flex-direction:column} }
</style>
</head>
<body>
  <div id="app">
    <div id="title">Hexanoid ‚Äî Infinite Mode</div>

    <div class="mode-select">
      <label for="modeSelect">–†–µ–∂–∏–º:</label>
      <select id="modeSelect">
        <option value="infinite">–ë–µ—Å–∫–æ–Ω–µ—á–Ω—ã–π</option>
        <option value="levels">–£—Ä–æ–≤–Ω–∏</option>
      </select>
      <select id="levelSelect" style="display:none">
        <option value="" disabled selected>–ó–∞–≥—Ä—É–∑–∫–∞ —É—Ä–æ–≤–Ω–µ–π...</option>
      </select>
      <span id="levelCompletion"></span>
    </div>

    <div class="speed-control">
      <label for="speedSlider">–°–∫–æ—Ä–æ—Å—Ç—å –∫–∏—Ä–ø–∏—á–µ–π:</label>
      <input type="range" id="speedSlider" min="0.01" max="0.1" step="0.01" value="0.02" style="width: 150px;">
      <span id="speedValue">0.02</span>
    </div>

    <div class="frame">
      <canvas id="gameCanvas" width="900" height="540" aria-label="game canvas"></canvas>
    </div>

    <div id="status">–°—á–µ—Ç: 0 | –ñ–∏–∑–Ω–∏: 3</div>
    <div id="activePowerups"></div>
    <div class="controls">
      <button id="restartBtn">Restart</button>
      <button id="pauseBtn">Pause</button>
      <button id="muteBtn">Mute</button>
    </div>
  </div>

<script>
(async () => {
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  const statusEl = document.getElementById('status');
  const restartBtn = document.getElementById('restartBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const muteBtn = document.getElementById('muteBtn');
  const modeSelect = document.getElementById('modeSelect');
  const levelSelect = document.getElementById('levelSelect');
  const levelCompletion = document.getElementById('levelCompletion');
  const speedSlider = document.getElementById('speedSlider');
  const speedValue = document.getElementById('speedValue');
  const activePowerupsEl = document.getElementById('activePowerups');
  const titleEl = document.getElementById('title');

  // Game state
  const HEX_RADIUS = 24;
  let hexBricks = [];
  let balls = []; // –ú–Ω–æ–∂–µ—Å—Ç–≤–æ —à–∞—Ä–æ–≤
  let ballTrails = new Map(); // –¢—Ä–µ–∫–∏ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —à–∞—Ä–∞
  let powerups = []; // –ê–∫—Ç–∏–≤–Ω—ã–µ –±–æ–Ω—É—Å—ã
  let activeEffects = new Map(); // –ê–∫—Ç–∏–≤–Ω—ã–µ —ç—Ñ—Ñ–µ–∫—Ç—ã –±–æ–Ω—É—Å–æ–≤
  let paddle = { x: 0, y: 0, width: 120, height: 12, speed: 8 };
  let running = true;
  let paused = false;
  let muted = false;
  let score = 0;
  let lives = 3;
  let levelComplete = false;
  let fileAccessWarningShown = false;
  let brickSpeed = 0.02; // –ë–∞–∑–æ–≤–∞—è —Å–∫–æ—Ä–æ—Å—Ç—å –¥–≤–∏–∂–µ–Ω–∏—è –∫–∏—Ä–ø–∏—á–µ–π
  let spawnTimer = 0;
  const SPAWN_INTERVAL = 2000; // –ò–Ω—Ç–µ—Ä–≤–∞–ª –ø–æ—è–≤–ª–µ–Ω–∏—è –Ω–æ–≤—ã—Ö –∫–∏—Ä–ø–∏—á–µ–π (–º—Å)
  
  // –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –±–µ—Å–∫–æ–Ω–µ—á–Ω–æ–≥–æ —Ä–µ–∂–∏–º–∞
  const INFINITE_SETTINGS = {
    maxBricksPerRow: 8,
    minBricksPerRow: 2,
    brickColors: ['#c94c4c', '#4cc98a', '#4c7ac9', '#c9c24c', '#4cc9c6', '#c84cc9'],
    powerupColors: ['#ff6b6b', '#4d96ff', '#9b59b6', '#f39c12'], // –†–∞–∑–Ω—ã–µ —Ü–≤–µ—Ç–∞ –¥–ª—è —Ä–∞–∑–Ω—ã—Ö –±–æ–Ω—É—Å–æ–≤
    powerupChance: 0.15, // 15% —à–∞–Ω—Å –ø–æ—è–≤–ª–µ–Ω–∏—è –±–æ–Ω—É—Å–∞
    gameOverLine: 500 // –õ–∏–Ω–∏—è, –ø—Ä–∏ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–∏ –∫–æ—Ç–æ—Ä–æ–π –∏–≥—Ä–∞ –∑–∞–∫–∞–Ω—á–∏–≤–∞–µ—Ç—Å—è
  };

  // –¢–∏–ø—ã –±–æ–Ω—É—Å–æ–≤
  const POWERUP_TYPES = {
    MULTIBALL: { 
      id: 'multiball', 
      name: '–ú—É–ª—å—Ç–∏—à–∞—Ä', 
      duration: 10000, // 10 —Å–µ–∫—É–Ω–¥
      color: '#ff6b6b',
      icon: '‚öΩ'
    },
    FREEZE: { 
      id: 'freeze', 
      name: '–ó–∞–º–æ—Ä–æ–∑–∫–∞', 
      duration: 8000, // 8 —Å–µ–∫—É–Ω–¥
      color: '#4d96ff',
      icon: '‚ùÑÔ∏è'
    },
    PIERCE: { 
      id: 'pierce', 
      name: '–ü—Ä–æ–±–∏–≤–Ω–æ–π', 
      duration: 12000, // 12 —Å–µ–∫—É–Ω–¥
      color: '#9b59b6',
      icon: 'üí•'
    },
    TRIPLE: { 
      id: 'triple', 
      name: '–¢—Ä–æ–π–Ω–æ–π', 
      duration: 7000, // 7 —Å–µ–∫—É–Ω–¥
      color: '#f39c12',
      icon: 'üî∂'
    }
  };

  // Level catalog
  const levelConfigs = [
    { value: 'Levels/level1.json', label: '–£—Ä–æ–≤–µ–Ω—å 1' },
    { value: 'Levels/level2.json', label: '–£—Ä–æ–≤–µ–Ω—å 2' },
    { value: 'Levels/level3.json', label: '–£—Ä–æ–≤–µ–Ω—å 3' },
    { value: 'Levels/level4.json', label: '–£—Ä–æ–≤–µ–Ω—å 4' },
    { value: 'Levels/level5.json', label: '–£—Ä–æ–≤–µ–Ω—å 5' },
    { value: 'Levels/level6.json', label: '–£—Ä–æ–≤–µ–Ω—å 6' },
    { value: 'Levels/custom.json', label: '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–π' }
  ];

  // Speed slider
  speedSlider.addEventListener('input', (e) => {
    brickSpeed = parseFloat(e.target.value);
    speedValue.textContent = brickSpeed.toFixed(2);
  });

  // Mode selection
  modeSelect.addEventListener('change', (e) => {
    if (e.target.value === 'infinite') {
      levelSelect.style.display = 'none';
      startInfiniteMode();
    } else {
      levelSelect.style.display = 'inline-block';
      populateLevelSelect();
      loadLevel(levelSelect.value || levelConfigs[0].value);
    }
  });

  function populateLevelSelect(){
    levelSelect.innerHTML = '';
    levelConfigs.forEach(cfg => {
      const option = document.createElement('option');
      option.value = cfg.value;
      option.textContent = cfg.label;
      levelSelect.appendChild(option);
    });
  }
  populateLevelSelect();

  // Resize canvas to frame
  function resizeCanvas() {
    const frameRect = document.querySelector('.frame').getBoundingClientRect();
    const w = Math.max(320, Math.floor(frameRect.width - 24));
    const h = Math.max(220, Math.floor(frameRect.height - 24));
    canvas.width = w;
    canvas.height = h;
    paddle.width = Math.max(60, Math.min(260, Math.floor(canvas.width * 0.14)));
    paddle.x = clamp(paddle.x || (canvas.width - paddle.width) / 2, 0, canvas.width - paddle.width);
    paddle.y = canvas.height - 18;
    INFINITE_SETTINGS.gameOverLine = canvas.height - 50; // –õ–∏–Ω–∏—è –ø—Ä–æ–∏–≥—Ä—ã—à–∞
  }
  window.addEventListener('resize', resizeCanvas);

  // Utilities
  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
  function randInt(min,max){ return Math.floor(Math.random()*(max-min+1))+min; }
  function randChoice(arr){ return arr[Math.floor(Math.random()*arr.length)]; }
  function distance(x1,y1,x2,y2){ return Math.hypot(x2-x1, y2-y1); }
  
  function lighten(hex, amt){
    const num = parseInt(hex.slice(1),16);
    const r = Math.min(255, ((num>>16) + 255*amt))|0;
    const g = Math.min(255, (((num>>8)&255) + 255*amt))|0;
    const b = Math.min(255, ((num & 255) + 255*amt))|0;
    return `rgb(${r},${g},${b})`;
  }

  // Draw hex with vertical gradient
  function drawHex(x,y,r,color,scale=1,alpha=1){
    ctx.save();
    ctx.translate(x,y);
    ctx.scale(scale,scale);
    ctx.globalAlpha = alpha;
    const grad = ctx.createLinearGradient(0,-r,0,r);
    grad.addColorStop(0, lighten(color, 0.28));
    grad.addColorStop(1, color);
    ctx.beginPath();
    for(let i=0;i<6;i++){
      const a = Math.PI/3 * i;
      const px = r * Math.cos(a);
      const py = r * Math.sin(a);
      i===0 ? ctx.moveTo(px,py) : ctx.lineTo(px,py);
    }
    ctx.closePath();
    ctx.fillStyle = grad;
    ctx.fill();
    ctx.lineWidth = Math.max(1, r * 0.06);
    ctx.strokeStyle = 'rgba(0,0,0,0.18)';
    ctx.stroke();
    ctx.restore();
  }

  // Draw powerup
  function drawPowerup(powerup){
    ctx.save();
    ctx.fillStyle = powerup.type.color;
    ctx.beginPath();
    ctx.arc(powerup.x, powerup.y, powerup.radius, 0, Math.PI*2);
    ctx.fill();
    
    // –ò–∫–æ–Ω–∫–∞ –±–æ–Ω—É—Å–∞
    ctx.fillStyle = '#fff';
    ctx.font = '16px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(powerup.type.icon, powerup.x, powerup.y);
    ctx.restore();
  }

  // –ë–µ—Å–∫–æ–Ω–µ—á–Ω—ã–π —Ä–µ–∂–∏–º
  function startInfiniteMode(){
    titleEl.textContent = 'Hexanoid ‚Äî –ë–µ—Å–∫–æ–Ω–µ—á–Ω—ã–π —Ä–µ–∂–∏–º';
    hexBricks = [];
    balls = [];
    powerups = [];
    activeEffects.clear();
    score = 0;
    lives = 3;
    levelComplete = false;
    paused = false;
    spawnTimer = performance.now();
    
    // –°–æ–∑–¥–∞–µ–º —Å—Ç–∞—Ä—Ç–æ–≤—ã–π —à–∞—Ä
    createBall();
    
    // –°–æ–∑–¥–∞–µ–º –Ω–∞—á–∞–ª—å–Ω—ã–µ –∫–∏—Ä–ø–∏—á–∏
    for(let i=0; i<5; i++){
      spawnBrickRow(i * 60);
    }
    
    statusEl.textContent = `–°—á–µ—Ç: ${score} | –ñ–∏–∑–Ω–∏: ${lives}`;
    updateActivePowerups();
  }

  // –°–æ–∑–¥–∞–Ω–∏–µ –Ω–æ–≤–æ–≥–æ —à–∞—Ä–∞
  function createBall(){
    const ball = {
      id: Date.now() + Math.random(),
      x: canvas.width / 2,
      y: canvas.height * 0.7,
      dx: 4 * (Math.random() < 0.5 ? 1 : -1),
      dy: -4,
      radius: 8,
      pierce: false, // –ü—Ä–æ–±–∏–≤–Ω–æ–π —Ä–µ–∂–∏–º
      trail: []
    };
    balls.push(ball);
    ballTrails.set(ball.id, []);
    return ball;
  }

  // –°–ø–∞–≤–Ω —Ä—è–¥–∞ –∫–∏—Ä–ø–∏—á–µ–π
  function spawnBrickRow(yOffset = 0){
    const bricksInRow = randInt(INFINITE_SETTINGS.minBricksPerRow, INFINITE_SETTINGS.maxBricksPerRow);
    const gridSize = HEX_RADIUS * 2.2;
    const maxAttempts = 50;
    const newBricks = [];
    
    for(let i=0; i<bricksInRow; i++){
      let attempts = 0;
      let placed = false;
      
      while(!placed && attempts < maxAttempts){
        const x = randInt(HEX_RADIUS, canvas.width - HEX_RADIUS);
        const y = -HEX_RADIUS - yOffset; // –ù–∞—á–∏–Ω–∞–µ–º –≤—ã—à–µ —ç–∫—Ä–∞–Ω–∞
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–µ —Å —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–º–∏ –∫–∏—Ä–ø–∏—á–∞–º–∏
        let collides = false;
        for(const brick of [...hexBricks, ...newBricks]){
          if(distance(x, y, brick.x, brick.y) < gridSize){
            collides = true;
            break;
          }
        }
        
        if(!collides){
          // –û–ø—Ä–µ–¥–µ–ª—è–µ–º, –±—É–¥–µ—Ç –ª–∏ –±–æ–Ω—É—Å –≤ –∫–∏—Ä–ø–∏—á–µ
          let containsPowerup = null;
          if(Math.random() < INFINITE_SETTINGS.powerupChance){
            const powerupTypes = Object.values(POWERUP_TYPES);
            containsPowerup = randChoice(powerupTypes);
          }
          
          newBricks.push({
            x: x,
            y: y,
            color: randChoice(INFINITE_SETTINGS.brickColors),
            hit: false,
            removing: false,
            removeStart: 0,
            containsPowerup: containsPowerup,
            powerupType: containsPowerup
          });
          placed = true;
        }
        attempts++;
      }
    }
    
    hexBricks.push(...newBricks);
  }

  // –°–ø–∞–≤–Ω –ø–∞–¥–∞—é—â–µ–≥–æ –±–æ–Ω—É—Å–∞
  function spawnPowerup(x, y, type){
    powerups.push({
      x: x,
      y: y,
      radius: 10,
      dy: 2,
      type: type
    });
  }

  // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –±–æ–Ω—É—Å–æ–≤
  function updatePowerups(){
    for(let i = powerups.length - 1; i >= 0; i--){
      const powerup = powerups[i];
      powerup.y += powerup.dy;
      
      // –°—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–µ —Å –ø–ª–∞—Ç—Ñ–æ—Ä–º–æ–π
      if(powerup.y + powerup.radius > paddle.y &&
         powerup.y - powerup.radius < paddle.y + paddle.height &&
         powerup.x + powerup.radius > paddle.x &&
         powerup.x - powerup.radius < paddle.x + paddle.width){
        
        activatePowerup(powerup.type);
        powerups.splice(i, 1);
        continue;
      }
      
      // –£–¥–∞–ª—è–µ–º, –µ—Å–ª–∏ —É–ø–∞–ª –∑–∞ —ç–∫—Ä–∞–Ω
      if(powerup.y - powerup.radius > canvas.height){
        powerups.splice(i, 1);
      }
    }
  }

  // –ê–∫—Ç–∏–≤–∞—Ü–∏—è –±–æ–Ω—É—Å–∞
  function activatePowerup(type){
    const now = performance.now();
    
    // –ï—Å–ª–∏ —ç—Ñ—Ñ–µ–∫—Ç —É–∂–µ –∞–∫—Ç–∏–≤–µ–Ω, —Å–±—Ä–∞—Å—ã–≤–∞–µ–º —Ç–∞–π–º–µ—Ä
    if(activeEffects.has(type.id)){
      activeEffects.set(type.id, { startTime: now, duration: type.duration });
    } else {
      activeEffects.set(type.id, { startTime: now, duration: type.duration });
      
      // –ü—Ä–∏–º–µ–Ω—è–µ–º –Ω–µ–º–µ–¥–ª–µ–Ω–Ω—ã–π —ç—Ñ—Ñ–µ–∫—Ç
      switch(type.id){
        case 'multiball':
          // –°–æ–∑–¥–∞–µ–º –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–π —à–∞—Ä
          const newBall = createBall();
          newBall.x = paddle.x + paddle.width / 2;
          newBall.y = paddle.y - newBall.radius;
          newBall.dx = 4 * (Math.random() < 0.5 ? 1 : -1);
          newBall.dy = -4;
          break;
          
        case 'triple':
          // –°–æ–∑–¥–∞–µ–º –¥–≤–∞ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã—Ö —à–∞—Ä–∞
          for(let i=0; i<2; i++){
            const tripleBall = createBall();
            tripleBall.x = paddle.x + paddle.width / 2;
            tripleBall.y = paddle.y - tripleBall.radius;
            const angle = (Math.PI/4) + (Math.random()-0.5) * 0.8;
            tripleBall.dx = 4 * Math.cos(angle);
            tripleBall.dy = -Math.abs(4 * Math.sin(angle));
          }
          break;
          
        case 'freeze':
          // –ó–∞–º–æ—Ä–æ–∑–∫–∞ —É–∂–µ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç—Å—è –≤ updateBricks
          break;
          
        case 'pierce':
          // –í–∫–ª—é—á–∞–µ–º –ø—Ä–æ–±–∏–≤–Ω–æ–π —Ä–µ–∂–∏–º –¥–ª—è –≤—Å–µ—Ö —à–∞—Ä–æ–≤
          balls.forEach(ball => ball.pierce = true);
          break;
      }
    }
    
    updateActivePowerups();
  }

  // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∞–∫—Ç–∏–≤–Ω—ã—Ö –±–æ–Ω—É—Å–æ–≤
  function updateActivePowerups(){
    const now = performance.now();
    
    // –£–¥–∞–ª—è–µ–º –∏—Å—Ç–µ–∫—à–∏–µ —ç—Ñ—Ñ–µ–∫—Ç—ã
    for(const [id, effect] of activeEffects){
      if(now - effect.startTime > effect.duration){
        activeEffects.delete(id);
        
        // –û—Ç–º–µ–Ω—è–µ–º —ç—Ñ—Ñ–µ–∫—Ç—ã
        if(id === 'pierce'){
          balls.forEach(ball => ball.pierce = false);
        }
      }
    }
    
    // –û–±–Ω–æ–≤–ª—è–µ–º –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ
    activePowerupsEl.innerHTML = '';
    for(const [id, effect] of activeEffects){
      const powerupType = Object.values(POWERUP_TYPES).find(p => p.id === id);
      if(powerupType){
        const remaining = Math.max(0, effect.duration - (now - effect.startTime));
        const elem = document.createElement('div');
        elem.className = `active-powerup powerup-${id}`;
        elem.innerHTML = `${powerupType.icon} ${powerupType.name}: ${(remaining/1000).toFixed(1)}s`;
        activePowerupsEl.appendChild(elem);
      }
    }
  }

  // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫–∏—Ä–ø–∏—á–µ–π
  function updateBricks(now){
    const freezeActive = activeEffects.has('freeze');
    
    // –î–≤–∏–≥–∞–µ–º –∫–∏—Ä–ø–∏—á–∏ –≤–Ω–∏–∑, –µ—Å–ª–∏ –Ω–µ—Ç –∑–∞–º–æ—Ä–æ–∑–∫–∏
    if(!freezeActive){
      for(const brick of hexBricks){
        brick.y += brickSpeed;
        
        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è –Ω–∏–∂–Ω–µ–π –≥—Ä–∞–Ω–∏—Ü—ã
        if(brick.y + HEX_RADIUS > INFINITE_SETTINGS.gameOverLine && !brick.hit){
          loseLife();
          brick.hit = true;
          brick.removing = true;
          brick.removeStart = now;
        }
      }
    }
    
    // –£–¥–∞–ª—è–µ–º —É–Ω–∏—á—Ç–æ–∂–µ–Ω–Ω—ã–µ –∫–∏—Ä–ø–∏—á–∏
    hexBricks = hexBricks.filter(brick => {
      if(brick.hit && brick.removing){
        const tt = now - brick.removeStart;
        if(tt > 360){
          // –ü—Ä–∏ —É–Ω–∏—á—Ç–æ–∂–µ–Ω–∏–∏ –∫–∏—Ä–ø–∏—á–∞ —Å –±–æ–Ω—É—Å–æ–º —Å–æ–∑–¥–∞–µ–º –ø–∞–¥–∞—é—â–∏–π –±–æ–Ω—É—Å
          if(brick.containsPowerup){
            spawnPowerup(brick.x, brick.y, brick.powerupType);
          }
          score += 100;
          return false;
        }
      }
      return true;
    });
    
    // –°–ø–∞–≤–Ω –Ω–æ–≤—ã—Ö –∫–∏—Ä–ø–∏—á–µ–π
    if(now - spawnTimer > SPAWN_INTERVAL){
      spawnBrickRow();
      spawnTimer = now;
    }
  }

  // –ü–æ—Ç–µ—Ä—è –∂–∏–∑–Ω–∏
  function loseLife(){
    lives--;
    if(lives <= 0){
      gameOver();
    } else {
      // –û—Å—Ç–∞–≤–ª—è–µ–º —Ç–æ–ª—å–∫–æ –æ–¥–∏–Ω —à–∞—Ä –ø–æ—Å–ª–µ –ø–æ—Ç–µ—Ä–∏ –∂–∏–∑–Ω–∏
      if(balls.length > 0){
        balls = [balls[0]];
        ballTrails.clear();
        ballTrails.set(balls[0].id, []);
        resetBall(balls[0]);
      }
      statusEl.textContent = `–°—á–µ—Ç: ${score} | –ñ–∏–∑–Ω–∏: ${lives}`;
    }
  }

  // –°–±—Ä–æ—Å —à–∞—Ä–∞
  function resetBall(ball){
    ball.x = canvas.width / 2;
    ball.y = canvas.height * 0.7;
    ball.dx = 4 * (Math.random() < 0.5 ? 1 : -1);
    ball.dy = -4;
    ballTrails.set(ball.id, []);
  }

  // Game Over
  function gameOver(){
    running = false;
    statusEl.textContent = `–ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞! –°—á–µ—Ç: ${score}`;
    alert(`–ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞!\n–í–∞—à —Å—á–µ—Ç: ${score}\n–ù–∞–∂–º–∏—Ç–µ Restart —á—Ç–æ–±—ã –∏–≥—Ä–∞—Ç—å —Å–Ω–æ–≤–∞.`);
  }

  // Draw scene
  function draw(now){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    
    // Background
    const g = ctx.createLinearGradient(0,0,0,canvas.height);
    g.addColorStop(0, '#0b0b0b');
    g.addColorStop(1, '#050505');
    ctx.fillStyle = g;
    ctx.fillRect(0,0,canvas.width,canvas.height);

    // bricks
    for (const b of hexBricks){
      if (b.hit && b.removing){
        const tt = now - b.removeStart;
        if (tt < 120){
          const p = tt / 120;
          drawHex(b.x, b.y, HEX_RADIUS, b.color, 1 + 0.15 * p, 1 - p*0.05);
        } else if (tt < 360){
          const p = (tt - 120) / 240;
          drawHex(b.x, b.y, HEX_RADIUS, b.color, Math.max(0, 1.15 * (1 - p)), Math.max(0, 1 - p));
        }
      } else if (!b.hit) {
        drawHex(b.x, b.y, HEX_RADIUS, b.color);
        
        // –†–∏—Å—É–µ–º –∏–∫–æ–Ω–∫—É –±–æ–Ω—É—Å–∞ –≤ –∫–∏—Ä–ø–∏—á–µ
        if(b.containsPowerup){
          ctx.save();
          ctx.fillStyle = '#fff';
          ctx.font = '14px Arial';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.globalAlpha = 0.9;
          ctx.fillText(b.containsPowerup.icon, b.x, b.y);
          ctx.restore();
        }
      }
    }

    // powerups
    for(const powerup of powerups){
      drawPowerup(powerup);
    }

    // paddle
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(paddle.x, paddle.y, paddle.width, paddle.height);
    ctx.globalAlpha = 0.06;
    ctx.fillStyle = '#0ff';
    const zoneW = paddle.width / 5;
    ctx.fillRect(paddle.x, paddle.y, zoneW, paddle.height);
    ctx.fillRect(paddle.x + 4*zoneW, paddle.y, zoneW, paddle.height);
    ctx.globalAlpha = 1;

    // –õ–∏–Ω–∏—è –ø—Ä–æ–∏–≥—Ä—ã—à–∞
    ctx.strokeStyle = '#ff4444';
    ctx.setLineDash([5, 5]);
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(0, INFINITE_SETTINGS.gameOverLine);
    ctx.lineTo(canvas.width, INFINITE_SETTINGS.gameOverLine);
    ctx.stroke();
    ctx.setLineDash([]);
    
    // –ò–Ω–¥–∏–∫–∞—Ç–æ—Ä –ø—Ä–æ–±–∏–≤–Ω–æ–≥–æ —Ä–µ–∂–∏–º–∞
    const pierceActive = activeEffects.has('pierce');
    if(pierceActive){
      ctx.fillStyle = 'rgba(155, 89, 182, 0.3)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    // trail and balls
    for(const ball of balls){
      const trail = ballTrails.get(ball.id) || [];
      for (let i=0;i<trail.length;i++){
        const p = trail[i];
        const a = (i+1)/trail.length;
        ctx.beginPath();
        ctx.arc(p.x, p.y, ball.radius * 0.6, 0, Math.PI*2);
        ctx.fillStyle = `rgba(255,80,80,${a*0.45})`;
        ctx.fill();
      }

      // ball
      ctx.beginPath();
      ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI*2);
      ctx.fillStyle = ball.pierce ? '#9b59b6' : '#ff4d4d';
      ctx.fill();
      
      // –ò–Ω–¥–∏–∫–∞—Ç–æ—Ä –ø—Ä–æ–±–∏–≤–Ω–æ–≥–æ —à–∞—Ä–∞
      if(ball.pierce){
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(ball.x, ball.y, ball.radius + 3, 0, Math.PI*2);
        ctx.stroke();
      }
    }

    // HUD
    ctx.fillStyle = '#ddd';
    ctx.font = '14px system-ui, Arial';
    ctx.fillText(`–°—á–µ—Ç: ${score}`, 10, 20);
    ctx.fillText(`–ñ–∏–∑–Ω–∏: ${lives}`, 10, 40);
    ctx.fillText(`–®–∞—Ä–æ–≤: ${balls.length}`, 10, 60);
    ctx.fillText(`–°–∫–æ—Ä–æ—Å—Ç—å: ${brickSpeed.toFixed(2)}`, canvas.width - 120, 20);
    
    // –ò–Ω–¥–∏–∫–∞—Ç–æ—Ä –∑–∞–º–æ—Ä–æ–∑–∫–∏
    if(activeEffects.has('freeze')){
      ctx.fillStyle = '#4d96ff';
      ctx.fillText('‚ùÑÔ∏è –ó–ê–ú–û–†–û–ó–ö–ê', canvas.width - 120, 40);
    }
    
    // –ò–≥—Ä–∞ –Ω–∞ –ø–∞—É–∑–µ
    if(paused){
      ctx.fillStyle = 'rgba(0,0,0,0.7)';
      ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 36px system-ui, Arial';
      ctx.textAlign = 'center';
      ctx.fillText('–ü–ê–£–ó–ê', canvas.width/2, canvas.height/2);
      ctx.font = '18px system-ui, Arial';
      ctx.fillText('–ù–∞–∂–º–∏—Ç–µ Pause –¥–ª—è –ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏—è', canvas.width/2, canvas.height/2 + 40);
      ctx.textAlign = 'left';
    }
  }

  // Physics and collisions
  function reflect(vx,vy,nx,ny){
    const dot = vx*nx + vy*ny;
    let rx = vx - 2*dot*nx;
    let ry = vy - 2*dot*ny;
    const minY = 1.2;
    if (Math.abs(ry) < minY){
      ry = ry < 0 ? -minY : minY;
      const speed = Math.sqrt(rx*rx + ry*ry) || 1;
      const cur = Math.sqrt(rx*rx + ry*ry) || 1;
      rx = rx * (speed/cur);
    }
    return { dx: rx, dy: ry };
  }

  function moveBall(ball, now){
    if(paused || !running) return;
    
    const trail = ballTrails.get(ball.id) || [];
    ball.x += ball.dx;
    ball.y += ball.dy;
    trail.push({ x: ball.x, y: ball.y });
    if (trail.length > 18) trail.shift();
    ballTrails.set(ball.id, trail);

    // walls
    if (ball.x < ball.radius){ ball.x = ball.radius; ball.dx *= -1; }
    if (ball.x > canvas.width - ball.radius){ ball.x = canvas.width - ball.radius; ball.dx *= -1; }
    if (ball.y < ball.radius){ ball.y = ball.radius; ball.dy *= -1; }

    // paddle collision
    if (ball.dy > 0 &&
        ball.y + ball.radius > paddle.y &&
        ball.y - ball.radius < paddle.y + paddle.height &&
        ball.x + ball.radius > paddle.x &&
        ball.x - ball.radius < paddle.x + paddle.width){
      const offset = (ball.x - (paddle.x + paddle.width/2)) / (paddle.width/2);
      const baseAngle = offset * (Math.PI/3);
      const variation = (Math.random() - 0.5) * (Math.PI/36);
      const final = baseAngle + variation;
      const speed = Math.max(2.2, Math.sqrt(ball.dx*ball.dx + ball.dy*ball.dy));
      ball.dx = speed * Math.sin(final);
      ball.dy = -Math.abs(speed * Math.cos(final));
      ball.y = paddle.y - ball.radius - 0.1;
    }

    // hex collisions
    for (const b of hexBricks){
      if (b.hit) continue;
      const cx = b.x, cy = b.y;
      const ddx = ball.x - cx, ddy = ball.y - cy;
      if (Math.hypot(ddx, ddy) > HEX_RADIUS + ball.radius) continue;

      // –í –ø—Ä–æ–±–∏–≤–Ω–æ–º —Ä–µ–∂–∏–º–µ –ø—Ä–æ—Å—Ç–æ —É–Ω–∏—á—Ç–æ–∂–∞–µ–º –∫–∏—Ä–ø–∏—á –±–µ–∑ –æ—Ç—Å–∫–æ–∫–∞
      if(ball.pierce){
        b.hit = true;
        b.removing = true;
        b.removeStart = now;
        score += 150; // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –æ—á–∫–∏ –∑–∞ –ø—Ä–æ–±–∏–≤–Ω–æ–π —Ä–µ–∂–∏–º
        continue; // –ü—Ä–æ–¥–æ–ª–∂–∞–µ–º –¥–≤–∏–∂–µ–Ω–∏–µ –±–µ–∑ –æ—Ç—Å–∫–æ–∫–∞
      }

      let collided = false;
      const rot = 0;
      for (let i=0;i<6;i++){
        const a1 = Math.PI/3 * i + rot;
        const a2 = Math.PI/3 * (i+1) + rot;
        const x1 = cx + HEX_RADIUS * Math.cos(a1);
        const y1 = cy + HEX_RADIUS * Math.sin(a1);
        const x2 = cx + HEX_RADIUS * Math.cos(a2);
        const y2 = cy + HEX_RADIUS * Math.sin(a2);
        const ex = x2 - x1, ey = y2 - y1;
        const t = ((ball.x - x1)*ex + (ball.y - y1)*ey) / (ex*ex + ey*ey);
        const tt = Math.max(0, Math.min(1, t));
        const px = x1 + ex * tt;
        const py = y1 + ey * tt;
        const dist = Math.hypot(ball.x - px, ball.y - py);
        if (dist <= ball.radius + 0.001){
          let nx = (ball.x - px) / (dist || 1);
          let ny = (ball.y - py) / (dist || 1);
          const r = reflect(ball.dx, ball.dy, nx, ny);
          ball.dx = r.dx; ball.dy = r.dy;
          b.hit = true;
          b.removing = true;
          b.removeStart = now;
          collided = true;
          break;
        }
      }
      if (collided) break;
    }

    // fallen below
    if (ball.y - ball.radius > canvas.height){
      // –£–¥–∞–ª—è–µ–º —à–∞—Ä, –µ—Å–ª–∏ –æ–Ω –Ω–µ –ø–æ—Å–ª–µ–¥–Ω–∏–π
      if(balls.length > 1){
        const index = balls.indexOf(ball);
        if(index > -1){
          balls.splice(index, 1);
          ballTrails.delete(ball.id);
        }
      } else {
        loseLife();
      }
    }
  }

  function moveBalls(now){
    for(const ball of balls){
      moveBall(ball, now);
    }
  }

  // Input: mouse, pointer, touch
  function pointerMove(clientX){
    if(paused || !running) return;
    const rect = canvas.getBoundingClientRect();
    const localX = clientX - rect.left;
    paddle.x = clamp(localX - paddle.width/2, 0, canvas.width - paddle.width);
  }

  canvas.addEventListener('pointerdown', e => pointerMove(e.clientX));
  canvas.addEventListener('pointermove', e => { if (e.buttons === 1) pointerMove(e.clientX); });
  canvas.addEventListener('touchstart', e => {
    if (e.touches && e.touches[0]) {
      pointerMove(e.touches[0].clientX);
    }
  }, { passive: true });
  canvas.addEventListener('touchmove', e => {
    if (e.touches && e.touches[0]) {
      pointerMove(e.touches[0].clientX);
    }
  }, { passive: true });

  // Buttons
  restartBtn.addEventListener('click', () => { 
    if(modeSelect.value === 'infinite'){
      startInfiniteMode();
    } else {
      // –î–ª—è —Ä–µ–∂–∏–º–∞ —É—Ä–æ–≤–Ω–µ–π
      loadLevel(levelSelect.value || levelConfigs[0].value);
    }
  });
  
  pauseBtn.addEventListener('click', () => { 
    paused = !paused; 
    pauseBtn.textContent = paused ? 'Resume' : 'Pause'; 
  });
  
  muteBtn.addEventListener('click', () => { 
    muted = !muted; 
    muteBtn.textContent = muted ? 'Unmute' : 'Mute'; 
  });
  
  levelSelect.addEventListener('change', (e) => {
    const selectedLevel = e.target.value;
    if (selectedLevel) loadLevel(selectedLevel);
  });

  // Game loop
  let lastTime = 0;
  function loop(now){
    if (!lastTime) lastTime = now;
    const dt = now - lastTime;
    lastTime = now;

    if(!paused && running){
      // keyboard paddle control
      if (keys['ArrowLeft']) paddle.x = clamp(paddle.x - paddle.speed, 0, canvas.width - paddle.width);
      if (keys['ArrowRight']) paddle.x = clamp(paddle.x + paddle.speed, 0, canvas.width - paddle.width);
      
      // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∏–≥—Ä—ã —Ç–æ–ª—å–∫–æ –≤ –±–µ—Å–∫–æ–Ω–µ—á–Ω–æ–º —Ä–µ–∂–∏–º–µ
      if(modeSelect.value === 'infinite'){
        updateBricks(now);
        updatePowerups();
        updateActivePowerups();
        moveBalls(now);
        
        // –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å
        statusEl.textContent = `–°—á–µ—Ç: ${score} | –ñ–∏–∑–Ω–∏: ${lives} | –®–∞—Ä–æ–≤: ${balls.length}`;
      }
    }

    draw(now);

    if (running) requestAnimationFrame(loop);
  }

  // keyboard state
  const keys = {};
  window.addEventListener('keydown', e => { 
    keys[e.key] = true;
    // –ü—Ä–æ–±–µ–ª –¥–ª—è –∑–∞–ø—É—Å–∫–∞ —à–∞—Ä–∞
    if(e.key === ' ' && balls.length === 1){
      balls[0].dx = 4 * (Math.random() < 0.5 ? 1 : -1);
      balls[0].dy = -4;
    }
  });
  window.addEventListener('keyup', e => { keys[e.key] = false; });

  // –§—É–Ω–∫—Ü–∏—è –∑–∞–≥—Ä—É–∑–∫–∏ —É—Ä–æ–≤–Ω—è (–¥–ª—è —Ä–µ–∂–∏–º–∞ —É—Ä–æ–≤–Ω–µ–π)
  async function loadLevel(path){
    // –†–µ–∞–ª–∏–∑–∞—Ü–∏—è –∑–∞–≥—Ä—É–∑–∫–∏ —É—Ä–æ–≤–Ω–µ–π –∏–∑ JSON —Ñ–∞–π–ª–æ–≤
    try {
      const res = await fetch(path, { cache: 'no-store' });
      if (!res.ok) throw new Error('fetch failed ' + res.status);
      const data = await res.json();
      // ... —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è –∑–∞–≥—Ä—É–∑–∫–∏ —É—Ä–æ–≤–Ω—è ...
    } catch (err) {
      console.error('Level load error', err);
      // –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫...
    }
  }

  // Init: resize, start infinite mode
  resizeCanvas();
  startInfiniteMode();
  lastTime = performance.now();
  running = true;
  requestAnimationFrame(loop);

  // Expose for debug
  window.__hexanoid = { 
    startInfiniteMode, 
    hexBricks, 
    balls,
    powerups,
    activeEffects,
    spawnBrickRow,
    activatePowerup
  };
})();
</script>
</body>
</html>